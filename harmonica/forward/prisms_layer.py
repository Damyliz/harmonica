"""
Define a layer of prisms
"""
import numpy as np
import xarray as xr
import verde as vd

from .prism import prism_gravity


def prisms_layer(
    region,
    shape=None,
    spacing=None,
    adjust="spacing",
    pixel_register=False,
    bottom=None,
    top=None,
    properties=None,
):
    """
    Parameters
    ----------
    bottom : float or None
    top : float or None
    properties : dict or None

    Returns
    -------
    dataset : :class:`xr.Dataset`
        Dataset containing the coordiantes of the center of each prism, the
        height of its top and bottom boundaries and its corresponding
        properties.
    """
    dims = ("northing", "easting")
    if top is None:
        top = np.nan
    if bottom is None:
        bottom = np.nan
    coordinates = vd.grid_coordinates(
        region,
        shape=shape,
        spacing=spacing,
        adjust=adjust,
        pixel_register=pixel_register,
        extra_coords=[bottom, top],
    )
    # Generate xr.Dataset.
    # Would use vd.build_grid, but for now I copy paste the code:
    coords = {dims[1]: coordinates[0][0, :], dims[0]: coordinates[1][:, 0]}
    coords["bottom"] = (dims, coordinates[2])
    coords["top"] = (dims, coordinates[3])
    data_vars = None
    if properties:
        data_vars = {
            prop: (dims, value * np.ones_like(coordinates[0]))
            for prop, value in properties.items()
        }
    return xr.Dataset(data_vars=data_vars, coords=coords)


@xr.register_dataset_accessor("prisms_layer")
class PrismsLayer:
    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        self._spacing = None
        self._size = None

    @property
    def spacing(self):
        """
        Spacing between center of prisms

        Returns
        -------
        s_north : float
            Spacing between center of prisms on the South-North direction.
        s_east : float
            Spacing between center of prisms on the West-East direction.
        """
        if self._spacing is None:
            self._spacing = (
                self._obj.northing.values[1] - self._obj.northing.values[0],
                self._obj.easting.values[1] - self._obj.easting.values[0],
            )
        return self._spacing

    @property
    def boundaries(self):
        """
        Boundaries of the layer

        Returns
        -------
        boundaries : tuple
            Boundaries of the layer of prisms in the following order: ``west``,
            ``east``, ``south``, ``north``.
        """
        s_north, s_east = self.spacing
        west = self._obj.easting.values.min() - s_east / 2
        east = self._obj.easting.values.max() + s_east / 2
        south = self._obj.northing.values.min() - s_north / 2
        north = self._obj.northing.values.max() + s_north / 2
        return west, east, south, north

    @property
    def size(self):
        """
        Return the total number of prisms on the layer

        Returns
        -------
        size : int
            Total number of prisms in the layer.
        """
        if self._size is None:
            self._size = self._obj.northing.size * self._obj.easting.size
        return self._size

    @property
    def shape(self):
        """
        Return the number of prisms on each direction

        Returns
        -------
        n_north : int
            Number of prisms on the South-North direction.
        n_east : int
            Number of prisms on the West-East direction.
        """
        return (self._obj.northing.size, self._obj.easting.size)

    def _prism_boundaries(self, easting, northing):
        """
        Compute the boundaries of the prism from the coordinates of its center

        Parameters
        ----------
        easting : float or array
            Easting coordinate of the center of the prism
        northing : float or array
            Northing coordinate of the center of the prism
        """
        west = easting - self.spacing[1] / 2
        east = easting + self.spacing[1] / 2
        south = northing - self.spacing[0] / 2
        north = northing + self.spacing[0] / 2
        return west, east, south, north

    def gravity(self, coordinates, field, **kwargs):
        """
        Computes the gravity generated by the layer

        All ``kwargs`` will be passed to :func:`harmonica.prism_gravity`.

        Parameters
        ----------
        coordinates : list or 1d-array
            List or array containing ``easting``, ``northing`` and ``upward``
            of the computation points defined on a Cartesian coordinate system.
            All coordinates should be in meters.
        field : str
            Gravitational field that wants to be computed.
            The available fields are:

            - Gravitational potential: ``potential``
            - Downward acceleration: ``g_z``

        Returns
        -------
        result : array
            Gravitational field generated by the prisms on the computation
            points.

        See also
        --------
        harmonica.prism_gravity
        """
        return prism_gravity(
            coordinates, self.get_prisms(), self._obj.density, field=field, **kwargs
        )

    def get_prisms(self):
        """
        Return the boundaries of each prism of the layer

        Returns
        -------
        prisms : 2d-array
            Array containing the boundaries of each prism of the layer.
            Each row contains the boundaries of each prism in the following
            order: ``west``, ``east``, ``south``, ``north``, ``bottom``,
            ``top``.
        """
        # The meshgrid must be done on this order (northing and then easting)
        # to follow the same index ordering as the data_vars
        northing, easting = np.meshgrid(
            self._obj.northing.values, self._obj.easting.values
        )
        west, east, south, north = self._prism_boundaries(
            easting.ravel(), northing.ravel()
        )
        bottom = self._obj.bottom.values.ravel()
        top = self._obj.top.values.ravel()
        prisms = np.vstack((west, east, south, north, bottom, top)).T
        return prisms

    def get_prism(self, indices):
        """
        Return the prism corresponding to the index

        Parameters
        ----------
        indices : tuple
            Indices of the desired prism of the layer in  the following order:
            ``(index_northing, index_easting)``.

        Returns
        -------
        prism : dict
           Dictionary containing ``"prism""`` and the boundaries of the prism
           and its properties.
        """
        # Get the center of the prism
        center_easting = self._obj.easting.values[indices[1]]
        center_northing = (self._obj.northing.values[indices[0]],)
        # Calculate the boundaries of the prism
        west, east, south, north = self._prism_boundaries(
            center_easting, center_northing
        )
        bottom, top = self._obj.bottom.values[indices], self._obj.top.values[indices]
        # Create dictionary
        prism = {
            prop: array.values[indices] for prop, array in self._obj.data_vars.items()
        }
        prism["prism"] = (west, east, south, north, bottom, top)
        return prism

    def __iter__(self):
        """
        Initialize iteration by setting counter to zero
        """
        self._n = 0
        return self

    def __next__(self):
        """
        Iterate over the prisms of the layer
        """
        if self._n >= self.size:
            raise StopIteration
        indices = np.unravel_index(self._n, shape=self.shape)
        prism = self.get_prism(indices)
        self._n += 1
        return prism
